# USART

## Configuration

The availabe usart channel of Robomaster board A are: `UART2`, `USART3`, `USART6`, `USART7`, `USART8`.

Among them, `UART2` can be connected to the DuPont line. `USART3`, `USART6`, `USART7`, `USART8` can be connected
to `11257W00-4P-S`.

The `USART3` line sequence is different from `USART6`, `USART7` and `USART8`.

The details are in table:

| Channel | RX  | TX   |
|---------|-----|------|
| UART2   | PD6 | PD5  |
| USART3  | PD9 | PD8  |
| USART6  | PG9 | PG14 |
| USART8  | PE0 | PE1  |
| USART7  | PE7 | PE8  |

## Usage

You can define your own communication protocol in `Core/Src/stm32f4xx_it.c`,
and rewrite function `USARTx_IRQHandler()`, for example,
If you want to only receive data enclosed in two parentheses,
you can write it like this:

```c
void USART2_IRQHandler(void)
{
  HAL_UART_IRQHandler(&huart2);
    if (uart2_buffer.state == UART_STATE_IDLE) {
        if (uart2_buffer.byte == '(') {
            uart2_buffer.pointer = 0;
            uart2_buffer.buffer[uart2_buffer.pointer++] = uart2_buffer.byte;
            uart2_buffer.state++;
        }
    } else if (uart2_buffer.state == 1) {
        uart2_buffer.buffer[uart2_buffer.pointer++] = uart2_buffer.byte;
        if (uart2_buffer.byte == ')') {
            uart2_buffer.buffer[uart2_buffer.pointer++] = '\0';
            uart2_buffer.state = UART_STATE_BUSY;
        }
    }
    HAL_UART_Receive_IT(&huart2, &uart2_buffer.byte, 1);
}
```

Among them, `HAL_UART_IRQHandler(&huartx)` and
`HAL_UART_Receive_IT(&huartx, &uartx_buffer.byte, 1)` are necessary,
and you can write other code between them.
`huartx` is the uart handle generated by STM32CubeMX,
and `uartx_buffer` is the buffer to save received data.

If you set `uartx_buffer.state` as `UART_STATE_BUSY`, you can rewrite
`UART_Service()` in `Core/Src/usart.c`. For example,
you can light led when receiving specific data.

```c
void UART_Service(void) {
    if (uart2_buffer.state == UART_STATE_BUSY) {
        LED_On();
        uart2_buffer.state = UART_STATE_IDLE;
    }
    if (uart3_buffer.state == UART_STATE_BUSY) {
        uart3_buffer.state = UART_STATE_IDLE;
    }
    if (uart6_buffer.state == UART_STATE_BUSY) {
        uart6_buffer.state = UART_STATE_IDLE;
    }
    if (uart7_buffer.state == UART_STATE_BUSY) {
        uart7_buffer.state = UART_STATE_IDLE;
    }
    if (uart8_buffer.state == UART_STATE_BUSY) {
        uart8_buffer.state = UART_STATE_IDLE;
    }
}
```

You can use `UART_TransmitString(UART_HandleTypeDef *uartHandle, char *format, ...)`
to transmit a format string just like `printf()`. For example:

```c
int number = 0;
UART_TransmitString(&huart2, "number:%d", number);
```

Or you can use ` UART_TransmitData(UART_HandleTypeDef *uartHandle, uint8_t *data, uint16_t len)`
to transmit an array. For example:

```c
UART_TransmitData((&huart2, buffer, sizeof(buffer));
```

# USB Virtual Serial Port

## Configuration

| Port      | Pin  |
|-----------|------|
| USB_FS_DM | PA11 |
| USB_FS_DP | PA12 |
| USB_FS_ID | PA10 |

## Usage

You can link board to you computer with a USB data cable,
and communicate with the board just like using serial port.
You can rewrite `USB_ProcessRxData(const uint8_t *buf, uint32_t len)`
in `Core/Src/usb.c` to define your own communication protocol.
For example,
If you want to only receive data enclosed in two parentheses,
you can write it like this:

```c
void USB_ProcessRxData(const uint8_t *buf, uint32_t len) {
    uint32_t i = 0;
    uint8_t byte = 0;
    for (i = 0; i < len; i++) {
        byte = buf[i];
        if (usb.state == UART_STATE_IDLE) {
            if (byte == '(') {
                usb.pointer = 0;
                usb.receive_buffer[usb.pointer++] = byte;
                usb.state++;
            }
        } else if (usb.state == 1) {
            usb.receive_buffer[usb.pointer++] = byte;
            if (byte == ')') {
                usb.receive_buffer[usb.pointer++] = '\0';
                usb.state = UART_STATE_BUSY;
            }
        }
    }
}
```

If you set `usb.state` as `UART_STATE_BUSY`, you can rewrite
`USB_Service()` in `Core/Src/usb.c`. For example:

```c
void USB_Service(void) {
    if (usb.state == UART_STATE_BUSY) {
        USB_TransmitData(usb.receive_buffer, sizeof(usb.receive_buffer));
        if (strcmp((const char *) (usb.receive_buffer), "(MPU)") == 0) {
            USB_TransmitString("Roll: %8.3lf\tPitch: %8.3lf\tYaw: %8.3lf\r\n", mpu_imu.rol, mpu_imu.pit, mpu_imu.yaw);
        } else if (strcmp((const char *) (usb.receive_buffer), "(WIT)") == 0) {
            WIT_ReadData(&wit_imu);
            USB_TransmitString("Roll:%.3f\tPit:%.3f\tYaw:%.3f", wit_imu.angle[0], wit_imu.angle[1], wit_imu.angle[2]);
        }
        usb.state = UART_STATE_IDLE;
    }
}
```

The usage of `USB_TransmitString()` is the same as `printf()`.

# IMU

There are two types of IMUs: onboard IMU `MPU6500` and WIT serial IMU `HWT101CT-TTL`.
`MPU6500` uses SPI communication method.
`HWT101CT-TTL` uses serial communication channel 2.

## Configuration

### MPU6500

| Port      | Pin |
|-----------|-----|
| SPI5_MOSI | PF9 |
| SPI5_SCK  | PF7 |
| SPI5_MISO | PF8 |
| SPI5_NSS  | PF6 |

### HWT101CT-TTL

| IMU | Board | Pin |
|-----|-------|-----|
| VCC | +5V   | +5V |
| GNG | GND   | GND |
| TX  | RX    | PD6 |
| RX  | TX    | PD5 |

## Usage

### MPU6500

You can put `MPU_Update()` in `while(1){}` or a `Timer` to update data.
And the structure `MPU_ImuTypeDef mpu_imu` defined in `Core/Inc/mpu6500.h` contains
all the data you need.

### HWT101CT-TTL

You can put `WIT_ReadData(&wit_imu)` in `while(1){}` or a `Timer` or others to update data.
And the structure `WIT_TypeDef wit_imu` defined in `Core/Inc/wit.h` contains
all the data you need.